# 392. Является ли подпоследовательностью

## Описание

Даны две строки `s` и `t`, верните `true`, если `s` является подпоследовательностью `t`, и `false` в противном случае.

Подпоследовательность строки - это новая строка, которая образована из исходной строки путем удаления некоторых (может быть ни одного) символов без нарушения относительных позиций оставшихся символов. (т.е. "ace" является подпоследовательностью "abcde", а "aec" - нет).

## Примеры

### Пример 1:

**Вход:** `s = "abc"`, `t = "ahbgdc"`
**Выход:** `true`

### Пример 2:

**Вход:** `s = "axc"`, `t = "ahbgdc"`
**Выход:** `false`

## Ограничения

- `0 <= s.length <= 100`
- `0 <= t.length <= 10^4`
- `s` и `t` состоят только из строчных английских букв.

## Дополнительно

Предположим, что существует много входящих `s`, скажем, `s1, s2, ..., sk`, где `k >= 10^9`, и вы хотите проверить по одному, есть ли у `t` его подпоследовательность. В этом сценарии, как бы вы изменили свой код?

## Решение

### Подход

Решение использует метод двух указателей для проверки, является ли строка `s` подпоследовательностью строки `t`. Алгоритм проходит по строке `t` и для каждого символа проверяет, совпадает ли он с текущим символом строки `s`. Если совпадает, то указатель строки `s` продвигается вперед.

### Оптимизации

1. **Проверка краевого случая**: Если длина строки `s` больше длины строки `t`, то `s` не может быть подпоследовательностью `t`. В этом случае алгоритм сразу возвращает `false` без необходимости проходить по строке `t`.

2. **Ранний выход из цикла**: Когда все символы строки `s` найдены в строке `t`, алгоритм прекращает дальнейший поиск и возвращает `true`. Это улучшает производительность в случаях, когда подпоследовательность находится ближе к началу строки `t`.

3. **Кэширование длины строки**: Длина строки `s` вычисляется один раз и сохраняется в переменной, чтобы избежать повторных вызовов функции `len()` в цикле.

4. **Итерация по символам**: Вместо итерации по индексам строки `t`, алгоритм напрямую итерирует по символам, что упрощает код и может немного улучшить производительность.

5. **Упрощенная логика**: Алгоритм использует один указатель для строки `s` и итерацию по строке `t` с помощью цикла `for`. Это упрощает код и делает его более читаемым.

### Сложность

- **Временная сложность**: O(n), где n - длина строки `t`. В худшем случае алгоритм проходит по строке `t` полностью.
- **Пространственная сложность**: O(1). Алгоритм использует только константное количество дополнительной памяти для хранения указателей.

### Тестирование

Решение сопровождается полным набором тестов, включая:
- Базовые случаи (примеры из задачи)
- Краевые случаи (пустые строки, строки одинаковой длины)
- Случаи, когда `s` длиннее `t`
- Случаи с повторяющимися символами
- Случаи, когда подпоследовательность находится в конце или разряжена в строке `t`

Каждый тест содержит визуализацию позиций указателей для лучшего понимания работы алгоритма.

## Результат решения

![](./repo_pics/LeetCode.jpg)